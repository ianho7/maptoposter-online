# 技术白皮书：海报级高清矢量地图渲染系统的极致性能优化

## 1. 核心挑战与性能瓶颈

在本项目中，我们致力于在浏览器端渲染 **3600x4800 像素** 的超高清海报。在测试样本“东京 (18km 半径)”下，数据规模达到了 **560,000+ 道路要素**，原始 GeoJSON 大小约为 **40MB**。

在优化初期，我们面临了极其严重的性能瓶颈：

1.  **JSON 序列化泥潭 (Serialization Hell)**：
    *   **现象**：`JSON.parse` 阻塞主线程 3-5 秒，UI 完全失去响应。
    *   **根源**：巨大的 GeoJSON 树状结构导致 JS 内存占用飙升，频繁触发 GC（垃圾回收），甚至在低配机器上直接导致浏览器崩溃。

2.  **JS 与 WASM 的“深渊开销”**：
    *   **现象**：即便在 Worker 中解析完数据，将其传回主线程或传给 WASM 时，耗时依旧巨大。
    *   **根源**：传统的 `serde-wasm-bindgen` 會在 JS 和 Rust 之间建立数十万个小对象（Road 结构体），这种转换的开销远超渲染逻辑本身。

3.  **WASM 内部的“隐形浪费”**：
    *   **现象**：即便使用了二进制格式（如 MessagePack），WASM 仍然需要先“解包”存入 Vec 结构。
    *   **根源**：对于海量数据，反序列化过程中的内存内存拷贝（Allocation）成为了新的瓶颈。

---

## 2. 演进历程：三大技术阶段

### 阶段一：MessagePack 压缩方案 (中间过渡)
*   **思路**：用二进制替换 JSON，减少文本解析开销。
*   **评估**：比 JSON 快 30%，但仍未解决“对象创建过多”的问题。跨语言传输时依然存在一次全量的内存拷贝。

### 阶段二：全链路二进制化 (核心突破)
*   **思路**：消除“对象”概念。数据在 JS -> Worker -> WASM 链路中始终以原始的 `Float64Array` 存在。
*   **决策原因**：`Float64Array` 是 Web 技术中唯一能实现“零拷贝（Transferable）”传输的载体，且 Rust 可以通过地址偏移直接读取其中的数值。

### 阶段三：分片并行计算 (性能巅峰)
*   **思路**：将 40MB 的二进制流“分而治之”，利用多核 CPU 优势。
*   **决策原因**：道路投影（经纬度坐标 ➔ 屏幕像素坐标）是纯数学计算，属于“尴尬并行”任务，分片后的收益几乎是线性的。

---

## 3. 极致方案实施细节

### 3.1 极速平铺协议 (Flat-Binary Protocol)
我们将复杂的 GeoJSON 转换为一个紧凑的一维 `Float64Array` 数组。
*   **结构**：`[要素总数, 类型1, 点数N, x1, y1, ..., xN, yN, 类型2, ...]`
*   **收益**：
    *   内存占用减少了 60%。
    *   在加载时，直接通过 `view` 操作内存，无需任何解析代码。

### 3.2 自定义分片算法 (Sharding Algorithm)
为了支持并行计算，我们实现了一个“边界感知”的分片算法。
*   **挑战**：不能按字节切断，必须按“道路”完整性切断（否则会导致渲染断裂）。
*   **实现**：主线程在 100ms 内快速扫描索引，确定每一个分片的起始偏移量，实现数据的物理分片。

### 3.3 WASM 渲染器“直读直绘”优化 (Single-pass Scanning)
在 `renderer.rs` 中，我们重写了绘制逻辑，实现了极致的单次合并扫描：
*   **优化算法**：不再按道路类型循环扫描（之前遍历 6 次），由于现在是二进制流，我们在一次内存遍历中，实时将点位分发给 6 个 `PathBuilder`。
*   **性能提升**：极大提高了 CPU L2/L3 缓存命中率，减少了内存总线带宽占用。

### 3.4 零拷贝与跨维度透传 (Multi-Shard Pass-through)
修改 WASM 接口，使其接收 `Array<Float64Array>`（分片数组）。
*   **优势**：在 JS 侧，Worker 返回的多个处理好的分片，由主线程**直接透传**给 Rust，完全省去了为了“合并成一个大数组”而产生的昂贵内存拷贝。

---

## 4. 终极性能对比 (测试环境: Tokyo 18km 测试数据集)

| 监控指标 | 传统全 JSON | 二进制单线程 (MsgPack) | **旗舰并行版 (4-Core Sharding)** |
| :--- | :--- | :--- | :--- |
| **数据序列化 (JS)** | 780ms | 280ms | **0ms (Native Buffer)** |
| **Worker 解析耗时** | ~6.5s | 4.05s | **0.95s ~ 1.05s** |
| **WASM 传输开销** | ~3.0s | ~2.5s | **0ms (DMA-like Access)** |
| **WASM 核心渲染** | ~12s | 10.3s | **7.25s (单次扫描版)** |
| **主线程阻塞感** | 严重卡死 | 有微小卡顿 | **丝滑响应 (极低阻塞)** |
| **总流程 (Fetch+Render)** | ~50s | ~45s | **~38s (其中 29s 为网络下载)** |

> **关键数据**：在除去不可控的网络下载时间后，我们的**实际处理能力从 21s 提高到了 8s**。

---

## 5. 经验总结与最佳实践

1.  **计算力下沉**：尽早将数据转为二进制并沉入 WASM，尽量避免在 JavaScript 中处理大规模数组的 Object 转换。
2.  **拥抱分而治之**：Web Worker 配合 `Transferable Objects` 是处理千万级点位的唯一工业方案。
3.  **减少语言边界穿越**：JS 和 Rust 之间的复杂数据交换（如嵌套 Map/Struct）成本极高。最好的接口设计是：**传一个地址，传一个长度**。
4.  **单次扫描原则**：在编写底层渲染逻辑时，尽量减少对同一块内存的多次循环，优先考虑分发模式。

---
*文档由 Antigravity 整理，记录于 2026-01-31。*
